#!/usr/bin/env python
import numpy as np
import math
import rospy
import signal
#https://github.com/eric-wieser/ros_numpy
import ros_numpy
import sys
import cv2
from threading import Event
from std_msgs.msg import String
from sensor_msgs.msg import Image, PointCloud2, CameraInfo, JointState
import image_geometry
from cv_bridge import CvBridge, CvBridgeError
from visualization_msgs.msg import Marker
from geometry_msgs.msg import TransformStamped, PoseStamped, Point, Pose, PoseArray, Quaternion, Twist, Vector3
from std_msgs.msg import ColorRGBA
from authoring_msgs.msg import Action, Command, POI, POIArray
from panda_ros_msgs.msg import HybridPose
import copy
from tf.transformations import quaternion_from_euler
import tf
import tf2_ros
import tf2_geometry_msgs
import PyKDL


REFERENCE_FRAME='panda_link0'
CAMERA_FRAME='camera1'

class Parser(object):
    def __init__(self):
        self._tfBuffer = tf2_ros.Buffer()
        self._tl = tf2_ros.TransformListener(self._tfBuffer)
        rospy.sleep(0.5) # sleep a bit to make sure the TF cache is filled
        self._pose_pub = rospy.Publisher("/grasping_point",PoseStamped,queue_size=1)
        self._command_pub = rospy.Publisher("/parser/command", Command, queue_size=1)
        self._marker_pub = rospy.Publisher("/gui/markers", Marker, queue_size=1)

        self._virtual = rospy.get_param('~only_virtual')
        self._camera_topic = "/rgb/" if not self._virtual else "/virtual_camera/"

        print(self._camera_topic+"camera_info")

        self._model = image_geometry.PinholeCameraModel()
        self._model.fromCameraInfo(rospy.wait_for_message(self._camera_topic+"camera_info", CameraInfo))

        self._gui_pub = rospy.Publisher("/parser/gui_info",String,queue_size=1)
        self._panda_command = rospy.Publisher("/panda/commands",String, queue_size=1)

        self._br = tf2_ros.TransformBroadcaster()
        rospy.sleep(.5)
        self._pois = []
        self._poi_gui = ""
        self._poi_sub = rospy.Subscriber("/world_state/pois", POIArray, self.on_poi, queue_size = 1)
        self._command_sub = rospy.Subscriber("/gui/command", String, self.on_command, queue_size = 1)
        self._event_sub = rospy.Subscriber("/event", String, self.on_event, queue_size = 1)
        self._event_pub = rospy.Publisher("/event", String, queue_size = 1)
        if self._virtual:
            self._joint_sub = rospy.Subscriber("/simulator/joint_states", JointState, self.on_joints)
        else:
            self._joint_sub = rospy.Subscriber("/panda/joint_states", JointState, self.on_joints)
        self._depth_sub = rospy.Subscriber("depth_to_rgb/image_raw", Image, self._on_depth)
        
        self._joints = None
        self._camera_t = None
        self._freq = 1
        self._saved_view = []
        self._depth = None
        self._numpy_depth = None
        self._new_depth = True
    
    def _on_depth(self,msg):
        self._depth = msg
        self._new_depth = True

    def on_joints(self, msg):
        self._joints = msg.position

    def on_event(self, msg):
        l = msg.data.split(";")
        event = l[0]
        
        if event == "motion_finished" or event == "wait":
            self.publish_pois()

    def on_poi(self, msg):
        self._pois = []
        for p in msg.poi_array:
            self._pois.append(p)
        self.publish_pois()

    def publish_pois(self):
        self._poi_gui="poi;"
        done = False
        while not done:
            try:
                for p in self._pois:
                    #Inform interface of poi
                    pixel = self.get_pixel_from_pose(p.pose)
                    if pixel is None:
                        continue
                    name = self.get_name(p)
                    self._poi_gui+=name+":"+pixel+";"

                self._poi_gui = self._poi_gui[:-1]
                self._gui_pub.publish(self._poi_gui)
                done = True
            except:
                pass
        t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, 'panda_gripper', rospy.Time(0)).transform
        p = t.translation
        q = t.rotation
        e = tf.transformations.euler_from_quaternion([q.x,q.y,q.z,q.w])
        e = [v*180/np.pi for v in e]
        self._gui_pub.publish("panda_pose;"+str(round(p.x,3))+","+str(round(p.y,3))+","+str(round(p.z,3))+","+str(round(e[0],1))+","+str(round(e[1],1))+","+str(round(e[2],1)))

    def get_vect(self, v):
        toreturn = []
        try:
            toreturn.append(v.x)
            toreturn.append(v.y)
            toreturn.append(v.z)
            toreturn.append(v.w)
        except:
            pass
        return toreturn

    def get_name(self, poi):
        return poi.type.data + ":" + str(poi.id)

    def get_pose_from_pixel(self,x,y):
        if self._depth is None: 
            return None
        if self._new_depth:
            self._numpy_depth = ros_numpy.numpify(self._depth)
            self._new_depth = False
        d = self._numpy_depth[y,x]
        if d == 0.0:
            print("bad depth")
            self._gui_pub.publish(String("bad_depth"))
            return None
        point = self.get_xyz_from_pixel(x,y,d)
        p = PoseStamped()
        p.header.frame_id = CAMERA_FRAME
        p.header.stamp = rospy.Time(0)
        p.pose.position = point
        p.pose.orientation.w = 1
        return p

    def get_rotated_point(self, coord):
        coord = coord.split(',')
        p = self.get_pose_from_pixel(int(coord[0]),int(coord[1]))
        if p == None:
            return None
        p = self._tfBuffer.transform(p,REFERENCE_FRAME)
        q = PyKDL.Rotation.RPY(0,0,float(coord[2])/180*np.pi).GetQuaternion()
        p.pose.orientation.x=q[0]
        p.pose.orientation.y=q[1]
        p.pose.orientation.z=q[2]
        p.pose.orientation.w=q[3]
        h = self.get_hybrid_pose(p)
        return h

    def get_xyz_from_pixel(self,x,y,d):
        p = [x,y]
        p = self._model.rectifyPoint(p)
        p3d = self._model.projectPixelTo3dRay(p)
        point = Point()
        point.x=d/p3d[2]*p3d[0]
        point.y=d/p3d[2]*p3d[1]
        point.z=d/p3d[2]*p3d[2]
        return point
    
    def get_pixel_from_pose(self, pose):
        p = self._tfBuffer.transform(pose,CAMERA_FRAME)
        p = p.pose.position
        if p.z < 0:
            return None
        p=[p.x,p.y,p.z]
        pixel = self._model.project3dToPixel(p)
        return str(int(pixel[0]))+","+str(int(pixel[1]))

    def get_pixel_from_point(self, p):
        pose = PoseStamped()
        pose.pose.position = p
        pose.pose.orientation.w = 1
        pose.header.frame_id = REFERENCE_FRAME
        return self.get_pixel_from_pose(pose)

    def publish_pose(self,point):
        pose = PoseStamped()
        pose.pose.position=point
        pose.pose.orientation.w=1
        pose.header.frame_id=CAMERA_FRAME
        pose = self._tfBuffer.transform(pose,REFERENCE_FRAME)
        q = tf.transformations.quaternion_from_euler(math.pi,0,0)
        pose.pose.orientation.x=q[0]
        pose.pose.orientation.y=q[1]
        pose.pose.orientation.z=q[2]
        pose.pose.orientation.w=q[3]
        pose.header.stamp=rospy.Time.now()
        self._pose_pub.publish(pose)

    def get_orientation_from_quaternion(self, q):
        rot = Quaternion()
        rot.x=q[0]
        rot.y=q[1]
        rot.z=q[2]
        rot.w=q[3]
        return rot

    def get_hybrid_pose(self, p):
        h = HybridPose()
        h.header = p.header
        h.pose = p.pose
        h.sel_vector = [1,1,1,1,1,1]
        h.constraint_frame.w = 1
        print(h)
        return h

    #from https://stackoverflow.com/questions/29643352/converting-hex-to-rgb-value-in-python
    def get_color(self, string, alpha):
        color = ColorRGBA()
        string=string.lstrip('#')
        (r,g,b) = tuple(int(string[i:i+2], 16)/255. for i in (0, 2, 4))
        color.r = r
        color.g = g
        color.b = b
        color.a=alpha
        return color

    def get_points(self, cmd):
        l = cmd.split("_")
        points = []
        for p in l:
            point = Point()
            coord = p.split(',')
            point.x = int(coord[0])
            point.y = int(coord[1])
            points.append(point)
        return points

    def get_pose_from_trans(self, t):
        pose = HybridPose()
        pose.pose.position.x = t.transform.translation.x
        pose.pose.position.y = t.transform.translation.y
        pose.pose.position.z = t.transform.translation.z
        pose.pose.orientation.x = t.transform.rotation.x
        pose.pose.orientation.y = t.transform.rotation.y
        pose.pose.orientation.z = t.transform.rotation.z
        pose.pose.orientation.w = t.transform.rotation.w
        pose.sel_vector=[1,1,1,1,1,1]
        pose.constraint_frame.w = 1
        return pose


    def on_command(self, message):
        list_actions = message.data.split(";")
        command_type = list_actions[0]
        if command_type == "pause":
            self._event_pub.publish("pause")
            return
        if command_type == "play":
            self._event_pub.publish("play")
            return
        if command_type == 'init_gui' or command_type == "lock":
            self.publish_pois()
        if command_type == 'save_view' and self._joints is not None:
            n = int(list_actions[1])
            if n > len(self._saved_view) - 1:
                self._saved_view.append(self._joints)
            else:
                self._saved_view[n] = self._joints
            return

        if command_type == 'load_view':
            n = int(list_actions[1])
            if n < len(self._saved_view):
                action = Action()
                action.poses.header.frame_id = REFERENCE_FRAME
                action.type = action.MOVE_ANGLE
                action.joint_pose = self._saved_view[n]
                pose = HybridPose()
                pose.constraint_frame.w = 1
                action.poses.poses.append(pose)
                cmd = Command()
                cmd.type = cmd.EXEC
                cmd.core_action.append(action)
                self._command_pub.publish(cmd)
                return
                
        if command_type == 'panda_goal':
            pose = [float(v) for v in list_actions[1].split(",")]
            r = [p*np.pi/180. for p in pose[3:]]
            print(r)
            rot = PyKDL.Rotation.RPY(r[0],r[1],r[2])
            q = rot.GetQuaternion()
            action = Action()
            action.pose.header.frame_id = REFERENCE_FRAME
            action.pose.pose.position.x = pose[0]
            action.pose.pose.position.y = pose[1]
            action.pose.pose.position.z = pose[2]
            action.pose.pose.orientation.x = q[0]
            action.pose.pose.orientation.y = q[1]
            action.pose.pose.orientation.z = q[2]
            action.pose.pose.orientation.w = q[3]
            action.pose.sel_vector = [1,1,1,1,1,1]
            action.pose.constraint_frame.w = 1
            action.type = action.MOVE
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == 'center':
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, 'rotated_camera', rospy.Time(0)).transform
            p = t.translation
            q = t.rotation
            e = tf.transformations.euler_from_quaternion([q.x,q.y,q.z,q.w])
            r = [e[0],e[1],e[2]]

            dimensions = list_actions[1].split(",")
            if "x" in dimensions:
                r[0] = 0
            if "y" in dimensions:
                r[1] = 0
            if "z" in dimensions:
                r[2] = 0
            

            rot = PyKDL.Rotation.RPY(r[0],r[1],r[2])
            q = rot.GetQuaternion()
            action = Action()
            action.pose.header.frame_id = REFERENCE_FRAME
            action.pose.pose.position.x = p.x
            action.pose.pose.position.y = p.y
            action.pose.pose.position.z = p.z
            action.pose.pose.orientation.x = q[0]
            action.pose.pose.orientation.y = q[1]
            action.pose.pose.orientation.z = q[2]
            action.pose.pose.orientation.w = q[3]
            action.pose.sel_vector = [1,1,1,1,1,1]
            action.pose.constraint_frame.w = 1
            action.type = action.VIEW
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == 'direct': 
            cmd = list_actions[1].split(":")
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            action.type = self.get_action_from_name(action,cmd[0])
            if cmd[0] == "test":
                point = cmd[1]
                coord = point.split(',')
                p = self.get_pose_from_pixel(int(coord[0]),int(coord[1]))             
                if p is not None:
                    p = self._tfBuffer.transform(p,REFERENCE_FRAME)
                    if p.pose.position.x>.67 or p.pose.position.z < 0 or p.pose.position.y > 0.28:
                        self._gui_pub.publish(String("out_of_reach"))
                        return      
                    self._gui_pub.publish(String("good_move"))
                    t = TransformStamped()
                    t.header = p.header
                    t.header.stamp = rospy.Time.now()
                    t.child_frame_id = "target"
                    t.transform.translation = p.pose.position
                    t.transform.rotation = p.pose.orientation
                    self._br.sendTransform(t)
                return
            if cmd[0] == "Go":
                delta = cmd[1].split(',')
                t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "panda_gripper", rospy.Time(0)) 
                pose = self.get_pose_from_trans(t)
                pose.pose.position.x += float(delta[0])/1000.
                pose.pose.position.y += float(delta[1])/1000.
                pose.pose.position.z += float(delta[2])/1000.
                action.poses.poses.append(pose)
                action.pose = pose
            elif len(cmd) == 1:
                pass
            elif cmd[1].find(",") == -1:
                item = cmd[1]
                t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, item, rospy.Time(0)) 
                pose = self.get_pose_from_trans(t)
                action.poses.poses.append(pose)
                action.pose = pose
                action.item = String(item)
            else:
                points = cmd[1]
                coord = points.split(',')
                start = self.get_pose_from_pixel(int(coord[0]),int(coord[1]))
                if start == None:
                    return
                start = self._tfBuffer.transform(start,REFERENCE_FRAME)
                q = PyKDL.Rotation.RPY(0,0,float(coord[2])/180*np.pi).GetQuaternion()
                start.pose.orientation.x=q[0]
                start.pose.orientation.y=q[1]
                start.pose.orientation.z=q[2]
                start.pose.orientation.w=q[3]
                h = HybridPose()
                h.header = start.header
                h.pose = start.pose
                h.sel_vector = [1,1,1,1,1,1]
                h.constraint_frame.w = 1
                action.pose = h
                action.poses.poses.append(h)
            if action.pose.pose.position.x>.67 or action.pose.pose.position.z < 0 or action.pose.pose.position.y>.28:
                self._gui_pub.publish(String("out_of_reach"))
                return        

            self._gui_pub.publish(String("good_move"))

            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            print(action)
            self._command_pub.publish(cmd)
            return

        if command_type == 'mouse':
            arg = list_actions[1].split(":")
            action = Action()
            q = PyKDL.Rotation.RPY(float(arg[3]),float(arg[4]),float(arg[5])).GetQuaternion()
            p = PoseStamped()
            p.header.stamp = rospy.Time(0)
            p.header.frame_id = "rotated_camera"
            p.pose.position.x = float(arg[0])
            p.pose.position.y = float(arg[1])
            p.pose.position.z = float(arg[2])
            p.pose.orientation.x = q[0]
            p.pose.orientation.y = q[1]
            p.pose.orientation.z = q[2]
            p.pose.orientation.w = q[3]
            p = self._tfBuffer.transform(p,"panda_link0")
            h = HybridPose()
            h.sel_vector = [1,1,1,1,1,1]
            h.constraint_frame.w = 1
            h.pose = p.pose
            h.header = p.header
            #t = TransformStamped()
            #t.header = p.header
            #t.child_frame_id = "camera_goal"
            #t.transform.translation = p.pose.position
            #t.transform.rotation = p.pose.orientation
            #self._br.sendTransform(t)
            
            action.type = action.VIEW
            action.pose = h
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == "go":
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "go_camera", rospy.Time(0)) 
            action.type = action.MOVE
            pose = self.get_pose_from_trans(t)
            action.poses.poses.append(pose) 
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == "reset_position":
            #self._panda_command.publish(String("release"))
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            action.type = action.RESET
            pose = HybridPose()
            pose.constraint_frame.w = 1
            #pose.position.x = 0.35
            #pose.position.y = 0.
            #pose.position.z = 0.7
            #pose.position.x = 0.3
            #pose.position.y = 0.
            #pose.position.z = 0.5
            #q = tf.transformations.quaternion_from_euler(np.pi,0,-np.pi/2)
            #pose.orientation.x = q[0]
            #pose.orientation.y = q[1]
            #pose.orientation.z = q[2]
            #pose.orientation.w = q[3]
            action.poses.poses.append(pose)
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == "stop_sim":
            action = Action()
            action.type = action.STOP
            action.poses.header.frame_id = REFERENCE_FRAME
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "panda_gripper", rospy.Time(0)) 
            pose = self.get_pose_from_trans(t)
            action.poses.poses.append(pose) 
            cmd = Command()
            cmd.type = cmd.SIM
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == "stop":
            action = Action()
            action.type = action.STOP
            action.poses.header.frame_id = REFERENCE_FRAME
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "panda_gripper", rospy.Time(0)) 
            pose = self.get_pose_from_trans(t)
            action.poses.poses.append(pose) 
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == 'remove':
            cmd = list_actions[1].split(":")

            marker = Marker()
            if cmd[0] == "all":
                marker.action = marker.DELETEALL
                self._marker_pub.publish(marker)
                return
            marker.action = marker.DELETE
            marker.ns = cmd[0]
            marker.id = int(cmd[1])
            self._marker_pub.publish(marker)
            return
        actions = []

        list_actions.pop(0)
        #for action in list_actions:
        #    cmd = action.split(":")
        #    if len(cmd)>1 and cmd[1].find(",") != -1:
        #        try:
        #            #Only used if necessary?
        #            image = ros_numpy.numpify(rospy.wait_for_message("depth_to_rgb/image_raw", Image,timeout=1))
        #            break
        #        except Exception as e:
        #            print(e)
        #            return
        if self._depth is None:
            return
        moved = {}
        for action in list_actions:
            cmd = action.split(":")
        
            name = cmd[0]
            item = ""
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            #Get item name
            if cmd[0] == "Reset":
                action.poses.header.frame_id = REFERENCE_FRAME
                pose = HybridPose()
                pose.constraint_frame.w = 1
                action.poses.poses.append(pose)    
            elif cmd[1].find(",") == -1:
                item_list = cmd[1].split('-')
                for item in item_list:
                    if item in moved.keys():
                        action.poses.poses.append(moved[item])
                    else:
                        t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, item, rospy.Time(0)) 
                        pose = self.get_pose_from_trans(t)
                        action.poses.poses.append(pose)
                if cmd[0] == "Move":
                    action.item = String(cmd[1])
                    moved[item_list[0]]=action.poses.poses[-1]
                    moved[item_list[0]].pose.position.z+=.015
                else:
                    action.item = String(item_list[0])
                action.pose = action.poses.poses[0]
            else:
                if name == 'Move':
                    action.type = action.MOVE_UNKNOWN
                    points = cmd[1].split('_')
                    h_start = self.get_rotated_point(points[0])
                    h_end = self.get_rotated_point(points[1])
                    if h_start == None or h_end == None:
                        return
                    action.pose = h_start
                    action.poses.poses.append(h_start)
                    action.poses.poses.append(h_end)
                    action.item = String(cmd[1])
                    
                    for p in action.poses.poses:
                        if p.pose.position.x>.67 or p.pose.position.z < 0 or p.pose.position.y>.28:
                            self._gui_pub.publish(String("out_of_reach"))
                            return    

                    actions.append(action)

                    t = TransformStamped()
                    t.header = h_start.header
                    t.child_frame_id = "goal"
                    t.transform.translation = h_start.pose.position
                    t.transform.rotation = h_start.pose.orientation
                    self._br.sendTransform(t)
                    continue
                elif name == "Wipe":
                    coords = cmd[1].split('_')
                    h_grasp = self.get_rotated_point(coords[0])
                    if h_grasp == None:
                        return 
                    action.poses.poses.append(h_grasp)
                    action.pose = h_grasp
                    for coord in coords[1:]:
                        coord = coord.split(',')
                        pose = self.get_pose_from_pixel(int(coord[0]),int(coord[1]))
                        if pose == None:
                            return 
                        pose = self.get_hybrid_pose(self._tfBuffer.transform(pose,REFERENCE_FRAME))
                        pose.pose.orientation.x = 0
                        pose.pose.orientation.y = 0
                        pose.pose.orientation.z = 0
                        pose.pose.orientation.w = 1
                        action.poses.header = pose.header
                        action.poses.poses.append(pose)
                    action.item = String(cmd[1])
                else:
                    return

            for p in action.poses.poses:
                if p.pose.position.x>.67 or p.pose.position.z < 0 or p.pose.position.y>.28:
                    self._gui_pub.publish(String("out_of_reach"))
                    return        

            self._gui_pub.publish(String("good_move"))

            action.type = self.get_action_from_name(action, name)

            actions.append(action)

        cmd = Command()
        if command_type == "exec":
            cmd.type = cmd.EXEC
        if command_type == "sim":
            cmd.type = cmd.SIM
        if command_type == "viz":
            cmd.type = cmd.VIZ
        if command_type == "edit":
            cmd.type = cmd.EDIT
        for action in actions:
            cmd.core_action.append(action)
        if cmd.type != cmd.VIZ:
            self._command_pub.publish(cmd)
    def get_action_from_name(self, a, name):
        if name == 'Wipe':
            return a.WIPE
        if name == 'Grasp':
            return a.GRASP
        if name == 'Release':
            return a.RELEASE
        if name == 'MoveContact':
            return a.MOVE_TO_CONTACT
        if name == 'Go':
            return a.MOVE
        if name == 'Tighten':
            return a.SCREW
        if name == 'Loosen':
            return a.UNSCREW
        if name == 'Pick':
            return a.PICK
        if name == 'Place':
            return a.PLACE 
        if name == 'Move':
            return a.MOVE_OBJECT
        if name == 'Screw':
            return a.SCREW
        if name == 'Unscrew':
            return a.UNSCREW
        if name == 'Inspect':
            return a.INSPECT
        if name == 'Push':
            return a.PUSH
        if name == 'MoveUnknown':
            return a.MOVE_UNKNOWN
        if name == 'Reset':
            return a.RESET
        if name == 'Pull':
            return a.PULL

    def distance(self, p1, p2):
        return np.sqrt((p1.x-p2.x)**2+(p1.y-p2.y)**2+(p1.z-p2.z)**2)


    def run(self):
        r = rospy.Rate(self._freq)
        while not rospy.is_shutdown():
            self.publish_pois()
            r.sleep()

    def signal_handler(self, signal, frame):
        sys.exit()

if __name__ == "__main__":
    rospy.init_node('parser')
    parser = Parser()
    signal.signal(signal.SIGINT, parser.signal_handler)
    parser.run()
